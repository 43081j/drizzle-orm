## API updates

We are introducing a new parameter, `version`, to the `seed` function options. This parameter, which controls generator versioning, has been added to make it easier to update deterministic generators in the future. Since values should remain consistent after each regeneration, it is crucial to provide a well-designed API for gradual updates

```ts
await seed(db, schema, { version: 2 });
```

#### Example:

> This is not an actual API change; it is just an example of how we will proceed with `drizzle-seed` versioning

For example, `lastName` generator was changed, and new version, `V2`, of this generator became available.

Later, `firstName` generator was changed, making `V3` version of this generator available.

|                  |       `V1`       |      `V2`       |   `V3(latest)`   |
| :--------------: | :--------------: | :-------------: | :--------------: |
| **LastNameGen**  | `LastNameGenV1`  | `LastNameGenV2` |                  |
| **FirstNameGen** | `FirstNameGenV1` |                 | `FirstNameGenV3` |


##### Use the `firstName` generator of version 3 and the `lastName` generator of version 2
```ts
await seed(db, schema);
```

If you are not ready to use latest generator version right away, you can specify max version to use

##### Use the `firstName` generator of version 1 and the `lastName` generator of version 2
```ts
await seed(db, schema, { version: '2' });
```

##### Use the `firstName` generator of version 1 and the `lastName` generator of version 1.
```ts
await seed(db, schema, { version: '1' });
```

Each update with breaking changes for generators will be documented on our docs and in release notes, explaining which version you should use, if you are not ready to upgrade the way generators works

## Breaking changes

### `interval` unique generator was changed and upgraded to v2
### `string` generators were changed and upgraded to v2

## New Features

- added `fields` as new parameter in `interval` generator

`interval` generator generates intervals based on the following principle:

fields to the right of the last specified field are zeroed out, while fields to the left remain valid.

Thus, for example, there is no difference between the `year to month` fields and the `month` fields, because fields to the right of `month` (`day`, `hour`, `minute`, `second`) are zeroed out, while fields to the left (`year`) remain valid.

Example

```ts
import { pgTable, interval } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
  interval: interval(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals }, { count: 1000 }).refine((funcs) => ({
    intervals: {
      columns: {
        interval: funcs.interval({
          fields: "day to hour",
        }),
      },
    },
  }));
}

main();
```

You can also specify fields in a table and seed them automatically.

```ts
import { pgTable, interval } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
  interval: interval({ fields: "day to hour" }),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals }, { count: 1000 });
}

main();
```

## Breaking changes

- Unique `interval` generator was changed, so `2` version of this generator become available. **The latest version is `2`.**

**Cause:**

**Bug in generator:**
Old version of generator could generate intervals like: `1 minute 60 second`, `2 minute 0 second` and treat them as different intervals.

However, after inserting the `1 minute 60 second` interval, PostgreSQL database will convert it to `2 minute 0 second`. As a result, subsequent insertion of the `2 minute 0 second` interval into a unique column will cause an error.

##

- Both non-unique and unique `string` generators were changed, making version `2` of these generators available. **The latest version is `2`.**

**Cause:**

**Generating strings based on text-like column length:**
Now (in version 2), the maximum length of a string depends on the length of the text column (e.g., `varchar(20)`).
